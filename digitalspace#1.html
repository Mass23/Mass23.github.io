<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Digital Space #1 - Hello World</title>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; }
    </style>
</head>
<body>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        const sphereGeometry = new THREE.SphereGeometry(100, 32, 32);
        const textureLoader = new THREE.TextureLoader();
        const meImage = new Image();
        meImage.src = 'images/me.webp'; // Path to your image

        let sphereMaterial, sphere;
        const MAX_SPRITES = 10; // Limit for sprite pooling
        let helloWorldSprites = [];
        let meSprites = [];
        let pixelSprites = [];
        let spriteInterval = 1000; // Time interval for sprite creation

        meImage.onload = () => {
            createAndShuffleTexture(meImage, (shuffledTexture) => {
                sphereMaterial = new THREE.MeshBasicMaterial({ map: shuffledTexture, side: THREE.BackSide });
                sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
                scene.add(sphere);
                initializeSprites(); // Create sprite pools
                startSpriteCreation(); // Start creating sprites
            });
        };

        function createAndShuffleTexture(image, callback) {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = image.width;
            canvas.height = image.height;

            context.drawImage(image, 0, 0);
            const imageData = context.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;

            // Shuffle the pixels
            for (let i = data.length / 4 - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                const tmpIndex = i * 4;
                const jIndex = j * 4;
                [data[tmpIndex], data[tmpIndex + 1], data[tmpIndex + 2], data[tmpIndex + 3]] =
                    [data[jIndex], data[jIndex + 1], data[jIndex + 2], data[jIndex + 3]];
            }

            context.putImageData(imageData, 0, 0);
            const shuffledTexture = new THREE.Texture(canvas);
            shuffledTexture.needsUpdate = true;
            callback(shuffledTexture);
        }

        function initializeSprites() {
            // Pre-create 10 HelloWorldSprites
            for (let i = 0; i < MAX_SPRITES; i++) {
                helloWorldSprites.push(createHelloWorldSprite());
            }

            // Pre-create 10 MeSprites
            for (let i = 0; i < MAX_SPRITES; i++) {
                meSprites.push(createMeSprite());
            }

            // Pre-create 10 PixelSprites
            for (let i = 0; i < MAX_SPRITES; i++) {
                pixelSprites.push(createPixelSprite());
            }
        }

        function startSpriteCreation() {
            setInterval(() => {
                reuseSprite(helloWorldSprites);
                reuseSprite(meSprites);
                reuseSprite(pixelSprites);
            }, spriteInterval);
        }

        function createHelloWorldSprite() {
            const canvas = document.createElement('canvas');
            canvas.width = 128;
            canvas.height = 128;
            const context = canvas.getContext('2d');
            context.fillStyle = 'rgba(200, 200, 200, 0.5)';
            context.fillRect(0, 0, canvas.width, canvas.height);
            context.fillStyle = 'black';
            context.font = '16px Arial';
            context.textAlign = 'center';
            context.textBaseline = 'middle';
            context.fillText('HELLO WORLD', canvas.width / 2, canvas.height / 2);

            const spriteTexture = new THREE.Texture(canvas);
            spriteTexture.needsUpdate = true;

            return { sprite: new THREE.Sprite(new THREE.SpriteMaterial({ map: spriteTexture })), isActive: false };
        }

        function createPixelSprite() {
            const canvas = document.createElement('canvas');
            canvas.width = 256;
            canvas.height = 256;
            const context = canvas.getContext('2d');
            const x = Math.floor(Math.random() * (meImage.width - 128));
            const y = Math.floor(Math.random() * (meImage.height - 128));
            context.drawImage(meImage, x, y, 128, 128, 0, 0, 256, 256); // Scale down

            const spriteTexture = new THREE.Texture(canvas);
            spriteTexture.needsUpdate = true;

            return { sprite: new THREE.Sprite(new THREE.SpriteMaterial({ map: spriteTexture })), isActive: false };
        }

        function createMeSprite() {
            const canvas = document.createElement('canvas');
            canvas.width = 256;
            canvas.height = 256;
            const context = canvas.getContext('2d');
            const x = Math.floor(Math.random() * (meImage.width - 128));
            const y = Math.floor(Math.random() * (meImage.height - 128));
            context.drawImage(meImage, x, y, 128, 128, 0, 0, 256, 256); // Scale down

            const spriteTexture = new THREE.Texture(canvas);
            spriteTexture.needsUpdate = true;

            return { sprite: new THREE.Sprite(new THREE.SpriteMaterial({ map: spriteTexture })), isActive: false };
        }

        function reuseSprite(spritePool) {
            const inactiveSprite = spritePool.find(s => !s.isActive);

            if (inactiveSprite) {
                const sprite = inactiveSprite.sprite;

                // Positioning the sprite randomly
                const distanceFromCenter = 90; // Adjust position
                const phi = Math.random() * Math.PI; 
                const theta = Math.random() * 2 * Math.PI; 
                sprite.position.set(
                    distanceFromCenter * Math.sin(phi) * Math.cos(theta),
                    distanceFromCenter * Math.cos(phi),
                    distanceFromCenter * Math.sin(phi) * Math.sin(theta)
                );

                // Add to scene and mark as active
                scene.add(sprite);
                inactiveSprite.isActive = true;

                // After a short delay, mark it as inactive
                setTimeout(() => {
                    scene.remove(sprite);
                    inactiveSprite.isActive = false; // Mark as inactive
                }, 5000); // Duration in ms before reusing
            }
        }

        camera.position.set(0, 0, 0);

        // Mouse movement variables
        let isMouseDown = false;
        let lastMouseX = 0;
        let lastMouseY = 0;

        // Handle mouse movement
        window.addEventListener('mousedown', (event) => {
            isMouseDown = true;
            lastMouseX = event.clientX;
            lastMouseY = event.clientY;
        });

        window.addEventListener('mouseup', () => {
            isMouseDown = false;
        });

        window.addEventListener('mousemove', (event) => {
            if (isMouseDown) {
                const deltaX = event.clientX - lastMouseX;
                const deltaY = event.clientY - lastMouseY;

                // Update camera rotation based on mouse movement
                camera.rotation.y -= deltaX * 0.005; // Adjust sensitivity as needed
                camera.rotation.x -= deltaY * 0.005;

                // Clamp the camera's x rotation to prevent flipping
                camera.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, camera.rotation.x));

                lastMouseX = event.clientX;
                lastMouseY = event.clientY;
            }
        });

        // Touch event handlers for mobile support
        window.addEventListener('touchstart', (event) => {
            isMouseDown = true;
            lastMouseX = event.touches[0].clientX;
            lastMouseY = event.touches[0].clientY;
        });

        window.addEventListener('touchend', () => {
            isMouseDown = false;
        });

        window.addEventListener('touchmove', (event) => {
            if (isMouseDown) {
                const deltaX = event.touches[0].clientX - lastMouseX;
                const deltaY = event.touches[0].clientY - lastMouseY;

                // Update camera rotation based on touch movement
                camera.rotation.y -= deltaX * 0.005; // Adjust sensitivity as needed
                camera.rotation.x -= deltaY * 0.005;

                // Clamp the camera's x rotation to prevent flipping
                camera.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, camera.rotation.x));

                lastMouseX = event.touches[0].clientX;
                lastMouseY = event.touches[0].clientY;
            }
        });

        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
