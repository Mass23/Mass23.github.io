<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Three.js Sphere Viewer</title>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; }
    </style>
</head>
<body>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Set up scene, camera, and renderer
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setClearColor(0x000000, 1); // Set the background to black
        document.body.appendChild(renderer.domElement);
        
        // Sphere geometry
        const sphereGeometry = new THREE.SphereGeometry(100, 32, 32);
        const sphereMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff, side: THREE.BackSide });
        const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
        scene.add(sphere);

        // Set camera position
        camera.position.set(0, 0, 0);

        // Load the texture
        const textureLoader = new THREE.TextureLoader();
        const meImage = textureLoader.load('images/me.webp', (texture) => {
            meImage.texture = texture;
            console.log('Texture loaded:', texture); // Log when texture is loaded
            applyInitialGlitches();
        }, undefined, (error) => {
            console.error('Error loading texture:', error); // Log errors
        });

        // Create a canvas for glitches
        const glitchCanvas = document.createElement('canvas');
        const glitchContext = glitchCanvas.getContext('2d');
        glitchCanvas.width = 512; // Set canvas size
        glitchCanvas.height = 512;

        // Function to update the sphere texture
        function updateSphereTexture() {
            const texture = new THREE.Texture(glitchCanvas);
            texture.needsUpdate = true;
            sphereMaterial.map = texture;
            sphereMaterial.needsUpdate = true;
        }

        // Function to apply glitch effect
        function applyGlitchEffect() {
            // Clear the canvas
            glitchContext.clearRect(0, 0, glitchCanvas.width, glitchCanvas.height);

            // Draw the loaded image onto the glitch canvas
            if (meImage.texture && meImage.texture.image) {
                glitchContext.drawImage(meImage.texture.image, 0, 0, glitchCanvas.width, glitchCanvas.height);
            } else {
                console.log('Texture not loaded yet.');
                return;
            }

            // Create random glitches
            const glitchCount = 30; // Number of glitches to apply
            for (let i = 0; i < glitchCount; i++) {
                const x = Math.floor(Math.random() * glitchCanvas.width);
                const y = Math.floor(Math.random() * glitchCanvas.height);
                const width = Math.floor(Math.random() * 50); // Width of glitch segment
                const height = Math.floor(Math.random() * 50); // Height of glitch segment
                const imageData = glitchContext.getImageData(x, y, width, height);
                const glitchX = Math.floor(Math.random() * (glitchCanvas.width - width));
                const glitchY = Math.floor(Math.random() * (glitchCanvas.height - height));

                // Put the distorted segment back onto the canvas
                glitchContext.putImageData(imageData, glitchX, glitchY);
            }

            updateSphereTexture(); // Update the sphere's texture with the new glitch canvas
        }

        // Create initial glitches upon loading
        function applyInitialGlitches() {
            for (let i = 0; i < 10; i++) {
                applyGlitchEffect();
            }
            setInterval(applyGlitchEffect, 1000); // Continue to create glitches every second
        }

        // Variables for sprites
        const sprites = [];
        const MAX_SPRITES = 30; // Limit the number of sprites
        const spriteInterval = 5000; // Generate sprites every 5 seconds

        // Function to create "HELLO WORLD" sprite
        function createHelloWorldSprite() {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = 128;
            canvas.height = 128;

            // Draw a noisy square with "HELLO WORLD"
            context.fillStyle = 'rgba(200, 200, 200, 0.5)';
            context.fillRect(0, 0, canvas.width, canvas.height);
            context.fillStyle = 'black';
            context.font = '20px Arial';
            context.textAlign = 'center';
            context.textBaseline = 'middle';
            context.fillText('HELLO WORLD', canvas.width / 2, canvas.height / 2);

            const spriteTexture = new THREE.Texture(canvas);
            spriteTexture.needsUpdate = true;
            const spriteMaterial = new THREE.SpriteMaterial({ map: spriteTexture });
            const sprite = new THREE.Sprite(spriteMaterial);
            sprite.position.set((Math.random() - 0.5) * 80, (Math.random() - 0.5) * 80, -90); // Closer to the sphere surface
            scene.add(sprite);
            sprites.push(sprite);

            // Remove oldest sprite if limit exceeded
            if (sprites.length > MAX_SPRITES) {
                const oldestSprite = sprites.shift();
                scene.remove(oldestSprite);
            }
        }

        // Function to create larger pixel sprites
        function createPixelSprite() {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = 64;  // Increased size
            canvas.height = 64;

            // Draw a random pixel sample from the image
            const x = Math.floor(Math.random() * (meImage.texture.image.width - 64));
            const y = Math.floor(Math.random() * (meImage.texture.image.height - 64));
            context.drawImage(meImage.texture.image, x, y, 64, 64, 0, 0, 64, 64);

            const spriteTexture = new THREE.Texture(canvas);
            spriteTexture.needsUpdate = true;
            const spriteMaterial = new THREE.SpriteMaterial({ map: spriteTexture });
            const sprite = new THREE.Sprite(spriteMaterial);
            sprite.position.set((Math.random() - 0.5) * 80, (Math.random() - 0.5) * 80, -90); // Closer to the sphere surface
            scene.add(sprite);
            sprites.push(sprite);

            // Remove oldest sprite if limit exceeded
            if (sprites.length > MAX_SPRITES) {
                const oldestSprite = sprites.shift();
                scene.remove(oldestSprite);
            }
        }

        // Function to create a sprite from the me.webp image
        function createMeSprite() {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = 128;  // Size of the sprite
            canvas.height = 128;

            // Draw a random section of the me.webp image
            const x = Math.floor(Math.random() * (meImage.texture.image.width - canvas.width));
            const y = Math.floor(Math.random() * (meImage.texture.image.height - canvas.height));
            context.drawImage(meImage.texture.image, x, y, canvas.width, canvas.height, 0, 0, canvas.width, canvas.height);

            const spriteTexture = new THREE.Texture(canvas);
            spriteTexture.needsUpdate = true;
            const spriteMaterial = new THREE.SpriteMaterial({ map: spriteTexture });
            const sprite = new THREE.Sprite(spriteMaterial);
            sprite.position.set((Math.random() - 0.5) * 80, (Math.random() - 0.5) * 80, -90); // Closer to the sphere surface
            scene.add(sprite);
            sprites.push(sprite);

            // Remove oldest sprite if limit exceeded
            if (sprites.length > MAX_SPRITES) {
                const oldestSprite = sprites.shift();
                scene.remove(oldestSprite);
            }
        }

        // Create sprites every 5 seconds
        setInterval(() => {
            createHelloWorldSprite();
            createPixelSprite();
            createMeSprite(); // Create the me.webp sprite
        }, spriteInterval); // Generate sprites every 5 seconds

        // Create an initial batch of sprites
        for (let i = 0; i < 10; i++) {
            createHelloWorldSprite();
            createPixelSprite();
            createMeSprite();
        }

        // Mouse movement for camera rotation
        let isMouseDown = false;
        let previousMouseX = 0;
        let previousMouseY = 0;

        document.addEventListener('mousedown', (event) => {
            isMouseDown = true;
            previousMouseX = event.clientX;
            previousMouseY = event.clientY;
        });

        document.addEventListener('mousemove', (event) => {
            if (!isMouseDown) return;

            const deltaX = event.clientX - previousMouseX;
            const deltaY = event.clientY - previousMouseY;

            // Update camera rotation based on mouse movement
            camera.rotation.y -= deltaX * 0.005; // Adjust sensitivity
            camera.rotation.x -= deltaY * 0.005; // Adjust sensitivity

            previousMouseX = event.clientX;
            previousMouseY = event.clientY;
        });

        // Mouse up event to stop rotation
        document.addEventListener('mouseup', () => {
            isMouseDown = false;
        });

        // Resize event
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }
        animate();
    </script>
</body>
</html>
