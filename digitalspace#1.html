<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Three.js Fixed Pixel Sprites</title>
    <style>
        body { margin: 0; }
        canvas { display: block; }
    </style>
</head>
<body>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Scene setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Texture loader
        const textureLoader = new THREE.TextureLoader();
        const imageTexture = textureLoader.load('images/me.webp');

        // Create a sphere geometry (textured inside)
        const geometry = new THREE.SphereGeometry(20, 32, 32);
        const material = new THREE.MeshBasicMaterial({
            map: imageTexture,
            side: THREE.BackSide  // Texture is applied inside the sphere
        });
        const sphere = new THREE.Mesh(geometry, material);
        scene.add(sphere);

        // Function to create sprites with randomly sampled pixels from the image
        function createRandomSprites() {
            const spriteMaterial = new THREE.SpriteMaterial({ map: null, transparent: true, opacity: 1 });

            // Randomly sample a small portion from the texture
            const sampleX = Math.random() * (imageTexture.image.width - 100);
            const sampleY = Math.random() * (imageTexture.image.height - 100);

            const croppedTexture = new THREE.Texture(imageTexture.image);
            croppedTexture.offset.set(sampleX / imageTexture.image.width, sampleY / imageTexture.image.height);
            croppedTexture.repeat.set(100 / imageTexture.image.width, 100 / imageTexture.image.height);
            croppedTexture.needsUpdate = true;

            spriteMaterial.map = croppedTexture;

            const sprite = new THREE.Sprite(spriteMaterial);

            // Set a random position for the sprite within the sphere
            const radius = 15; // Random distance from the center
            const theta = Math.random() * 2 * Math.PI;
            const phi = Math.acos(2 * Math.random() - 1);
            sprite.position.set(
                radius * Math.sin(phi) * Math.cos(theta),
                radius * Math.sin(phi) * Math.sin(theta),
                radius * Math.cos(phi)
            );

            scene.add(sprite);

            // Slowly fade away
            const fadeTime = 3; // Seconds to fade
            let fadeOut = setInterval(() => {
                spriteMaterial.opacity -= 0.05;
                if (spriteMaterial.opacity <= 0) {
                    clearInterval(fadeOut);
                    scene.remove(sprite); // Remove the sprite when fully transparent
                }
            }, fadeTime * 1000 / 20); // Fade out over time
        }

        // Create sprites every few seconds
        setInterval(createRandomSprites, 1000);

        // Set camera position
        camera.position.z = 30;

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }

        animate();

        // Rotate camera in the opposite direction when clicking
        let isMouseDown = false;
        document.addEventListener('mousedown', () => { isMouseDown = true; });
        document.addEventListener('mouseup', () => { isMouseDown = false; });

        document.addEventListener('mousemove', (event) => {
            if (isMouseDown) {
                const movementX = event.movementX || event.mozMovementX || event.webkitMovementX || 0;
                const movementY = event.movementY || event.mozMovementY || event.webkitMovementY || 0;

                // Move camera in the opposite direction
                camera.rotation.y += movementX * 0.002;
                camera.rotation.x += movementY * 0.002;
            }
        });

    </script>
</body>
</html>
