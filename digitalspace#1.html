<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Three.js Sphere with Random Image Sampling</title>
    <style>
        body { margin: 0; }
        canvas { display: block; }
    </style>
</head>
<body>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Scene setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Sphere geometry
        const geometry = new THREE.SphereGeometry(5, 32, 32);

        // Function to create a random texture from an image
        function createRandomTexture(image, cropSize) {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');

            const randomX = Math.floor(Math.random() * (image.width - cropSize));
            const randomY = Math.floor(Math.random() * (image.height - cropSize));

            canvas.width = cropSize;
            canvas.height = cropSize;

            context.drawImage(image, randomX, randomY, cropSize, cropSize, 0, 0, cropSize, cropSize);

            return new THREE.CanvasTexture(canvas);
        }

        // Load the image and set it as the texture for the sphere
        const textureLoader = new THREE.TextureLoader();
        textureLoader.load('images/me.webp', (texture) => {
            const cropSize = 100; // Size of the crop
            const randomTexture = createRandomTexture(texture.image, cropSize);

            const sphereMaterial = new THREE.MeshBasicMaterial({
                map: randomTexture, 
                side: THREE.BackSide, // Render the inside of the sphere
            });

            const sphere = new THREE.Mesh(geometry, sphereMaterial);
            scene.add(sphere);
        });

        // Set camera position
        camera.position.set(0, 0, 0); // Camera at the center of the sphere

        // Function to create text texture
        function createTextTexture(text) {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            const width = 512;
            const height = 256;
            canvas.width = width;
            canvas.height = height;

            // Draw text on canvas
            context.fillStyle = 'rgba(255, 255, 255, 0.8)';
            context.fillRect(0, 0, width, height);
            context.font = 'bold 30px Arial'; // Adjusted font size
            context.textAlign = 'center';
            context.fillStyle = 'black'; // Text color
            context.fillText(text, width / 2, height / 2);
            
            const texture = new THREE.CanvasTexture(canvas);
            return texture;
        }

        // Function to generate random positions inside the sphere
        function getRandomPosition(radius) {
            const theta = Math.random() * Math.PI * 2; // Random angle
            const phi = Math.acos(Math.random() * 2 - 1); // Random elevation
            const x = radius * Math.sin(phi) * Math.cos(theta);
            const y = radius * Math.sin(phi) * Math.sin(theta);
            const z = radius * Math.cos(phi);
            return new THREE.Vector3(x, y, z);
        }

        // Function to create a sprite with image texture
        function createImageSprite(imagePath) {
            const textureLoader = new THREE.TextureLoader();
            textureLoader.load(imagePath, (texture) => {
                const spriteMaterial = new THREE.SpriteMaterial({ map: texture, color: 0xffffff });
                const sprite = new THREE.Sprite(spriteMaterial);
                sprite.scale.set(0.5, 0.5, 1); // Adjust scale for smaller sprite
                const position = getRandomPosition(3.5); // Position sprite randomly within the sphere
                sprite.position.copy(position);
                scene.add(sprite);

                // Fade out effect
                setTimeout(() => {
                    sprite.material.opacity = 1; // Reset opacity to fully visible
                    const fadeOut = () => {
                        if (sprite.material.opacity > 0) {
                            sprite.material.opacity -= 0.02; // Reduce opacity
                            requestAnimationFrame(fadeOut);
                        } else {
                            scene.remove(sprite); // Remove sprite after fade out
                        }
                    };
                    fadeOut();
                }, 2000); // Wait for 2 seconds before fading out
            });
        }

        // Function to add text inside the sphere
        function addTextToSphere(text) {
            const textTexture = createTextTexture(text);
            const textMaterial = new THREE.SpriteMaterial({ map: textTexture });
            const textSprite = new THREE.Sprite(textMaterial);
            textSprite.scale.set(1.5, 0.75, 1); // Smaller text sprite
            const position = getRandomPosition(3.5); // Position text randomly within the sphere
            textSprite.position.copy(position);
            scene.add(textSprite);

            // Fade out text after a delay
            setTimeout(() => {
                textSprite.material.opacity = 1; // Reset opacity to fully visible
                const fadeOutText = () => {
                    if (textSprite.material.opacity > 0) {
                        textSprite.material.opacity -= 0.02; // Reduce opacity
                        requestAnimationFrame(fadeOutText);
                    } else {
                        scene.remove(textSprite); // Remove text after fade out
                    }
                };
                fadeOutText();
            }, 2000); // Wait for 2 seconds before fading out
        }

        // Create images and text at random intervals
        setInterval(() => {
            const numElements = 5; // Number of images and texts to create each time
            for (let i = 0; i < numElements; i++) {
                createImageSprite('images/me.webp'); // Adjust the image path as needed
                addTextToSphere('HELLO WORLD');
            }
        }, 4000); // New sprites every 4 seconds

        // Mouse controls
        let mouseX = 0;
        let mouseY = 0;

        document.addEventListener('mousemove', (event) => {
            mouseX = (event.clientX / window.innerWidth) * 2 - 1; // Normalized device coordinates
            mouseY = -(event.clientY / window.innerHeight) * 2 + 1;
        });

        function animate() {
            requestAnimationFrame(animate);

            // Move camera based on mouse position
            camera.position.x += (mouseX - camera.position.x) * 0.1; // Interpolate towards mouse
            camera.position.y += (-mouseY - camera.position.y) * 0.1;
            camera.lookAt(0, 0, 0); // Look at the center of the sphere

            renderer.render(scene, camera);
        }

        animate(); // Start the animation loop

        // Handle window resizing
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
