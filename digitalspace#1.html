<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Three.js Glitched Sphere with Sprites</title>
    <style>
        :root {
            --red: #FF0000;
            --green: #00FF00;
            --blue: #0000FF;
            --black: #000000;
        }

        body {
            display: flex;
            justify-content: center;
            align-items: center;
            margin: 0;
            height: 100vh;
            font-family: 'Inter';
            background-color: var(--black);
            overflow: hidden; /* Prevent scrolling */
        }

        canvas {
            display: block; /* Ensures the canvas fills the window */
            position: absolute; /* Remove any margin or padding */
        }
    </style>
</head>
<body>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Scene setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ alpha: true }); // Allow transparency
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Texture loader
        const textureLoader = new THREE.TextureLoader();
        let imageTexture = textureLoader.load('images/me.webp', (texture) => {
            // Crop 50 pixels from each side
            const cropAmount = 50;
            const width = texture.image.width;
            const height = texture.image.height;

            texture.offset.set(cropAmount / width, cropAmount / height);
            texture.repeat.set((width - 2 * cropAmount) / width, (height - 2 * cropAmount) / height);
            texture.needsUpdate = true;
        });

        // Create a sphere geometry (textured inside)
        const geometry = new THREE.SphereGeometry(20, 32, 32);
        const material = new THREE.MeshBasicMaterial({
            map: imageTexture,
            side: THREE.BackSide // Texture is applied inside the sphere
        });
        const sphere = new THREE.Mesh(geometry, material);
        scene.add(sphere);

        // Create a glitch effect on the sphere texture
        function applyGlitchEffect() {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');

            // Set canvas dimensions
            canvas.width = imageTexture.image.width;
            canvas.height = imageTexture.image.height;

            // Draw the image on the canvas
            context.drawImage(imageTexture.image, 0, 0);

            // Glitch effect logic: randomly distort parts of the image
            for (let i = 0; i < 100; i++) { // Adjust number of glitches
                const x = Math.floor(Math.random() * canvas.width);
                const y = Math.floor(Math.random() * canvas.height);
                const width = Math.floor(Math.random() * 50); // Width of glitch segment
                const height = Math.floor(Math.random() * 50); // Height of glitch segment
                const imageData = context.getImageData(x, y, width, height);
                const glitchX = Math.floor(Math.random() * (canvas.width - width));
                const glitchY = Math.floor(Math.random() * (canvas.height - height));

                // Put the distorted segment back onto the canvas
                context.putImageData(imageData, glitchX, glitchY);
            }

            // Update the texture with the new canvas
            const newTexture = new THREE.Texture(canvas);
            newTexture.needsUpdate = true;
            material.map = newTexture;
        }

        // Create a sprite for "HELLO WORLD"
        function createTextSprite(text, size, color) {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = size;
            canvas.height = size;

            context.fillStyle = 'rgba(128, 128, 128, 0.5)'; // Grey background
            context.fillRect(0, 0, size, size);

            context.font = `${size / 5}px Arial`;
            context.fillStyle = color;
            context.textAlign = 'center';
            context.textBaseline = 'middle';
            context.fillText(text, size / 2, size / 2);

            const texture = new THREE.Texture(canvas);
            texture.needsUpdate = true;

            const spriteMaterial = new THREE.SpriteMaterial({ map: texture, transparent: true });
            const sprite = new THREE.Sprite(spriteMaterial);
            sprite.scale.set(size / 100, size / 100, 1); // Adjust the size of the sprite
            return sprite;
        }

        // Create a sprite for "me.webp" image
        function createImageSprite(texture, size) {
            const spriteMaterial = new THREE.SpriteMaterial({ map: texture, transparent: true });
            const sprite = new THREE.Sprite(spriteMaterial);
            sprite.scale.set(size / 100, size / 100, 1); // Adjust the size of the sprite
            return sprite;
        }

        // Array to hold sprites
        const sprites = [];
        function addSprites() {
            const numberOfSprites = 5; // Number of text sprites to create
            for (let i = 0; i < numberOfSprites; i++) {
                const size = 150; // Size of the square sprite
                const textSprite = createTextSprite("HELLO WORLD", size, "white");
                
                // Random position on the sphere
                const theta = Math.random() * Math.PI * 2; // Random angle
                const phi = Math.random() * Math.PI; // Random elevation

                textSprite.position.set(
                    20 * Math.sin(phi) * Math.cos(theta),
                    20 * Math.cos(phi),
                    20 * Math.sin(phi) * Math.sin(theta)
                );

                sprites.push(textSprite);
                scene.add(textSprite);
                
                // Create a random image sprite
                const imageSprite = createImageSprite(imageTexture, size);
                imageSprite.position.copy(textSprite.position);
                sprites.push(imageSprite);
                scene.add(imageSprite);
            }
        }

        // Fade out effect for sprites
        function fadeOutSprite(sprite) {
            const fadeDuration = 3000; // Duration in milliseconds
            let startTime = null;

            function animateFadeOut(timestamp) {
                if (!startTime) startTime = timestamp;
                const elapsed = timestamp - startTime;

                // Calculate the opacity based on elapsed time
                const opacity = Math.max(1 - (elapsed / fadeDuration), 0);
                sprite.material.opacity = opacity;

                if (opacity > 0) {
                    requestAnimationFrame(animateFadeOut);
                } else {
                    scene.remove(sprite); // Remove the sprite once faded out
                }
            }
            requestAnimationFrame(animateFadeOut);
        }

        // Generate sprites periodically
        setInterval(() => {
            addSprites();
            sprites.forEach(sprite => fadeOutSprite(sprite));
        }, 1000); // Adjust interval time

        // Generate pixel sprites
        const pixelSprites = [];
        function createPixelSprite() {
            const size = 50; // Size of pixel sprites
            const pixelSprite = new THREE.Sprite(new THREE.SpriteMaterial({ color: Math.random() * 0xffffff }));

            // Random position on the sphere
            const theta = Math.random() * Math.PI * 2; // Random angle
            const phi = Math.random() * Math.PI; // Random elevation

            pixelSprite.position.set(
                20 * Math.sin(phi) * Math.cos(theta),
                20 * Math.cos(phi),
                20 * Math.sin(phi) * Math.sin(theta)
            );

            pixelSprite.scale.set(size / 100, size / 100, 1); // Adjust size
            pixelSprites.push(pixelSprite);
            scene.add(pixelSprite);
        }

        // Update pixel sprite positions based on mouse movement
        function updatePixelSprites() {
            pixelSprites.forEach(sprite => {
                sprite.position.copy(camera.position);
                sprite.position.add(camera.getWorldDirection(new THREE.Vector3()).normalize().multiplyScalar(20)); // Move the sprite away from the camera
            });
        }

        // Generate pixel sprites periodically
        setInterval(() => {
            createPixelSprite();
        }, 300); // Generate pixel sprites every 300 milliseconds

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            applyGlitchEffect(); // Apply the glitch effect to the sphere's texture
            
            // Update pixel sprite positions based on camera direction
            updatePixelSprites();

            renderer.render(scene, camera);
        }

        animate();

        // Set camera position inside the sphere
        camera.position.set(0, 0, 0);

        // Mouse movement handling
        let mouseX = 0;
        let mouseY = 0;
        document.addEventListener('mousemove', (event) => {
            mouseX = (event.clientX / window.innerWidth) * 2 - 1;
            mouseY = -(event.clientY / window.innerHeight) * 2 + 1;
        });

        document.addEventListener('click', () => {
            // Here you can add functionality for click events
            // E.g. change camera direction or other interactions
        });
    </script>
</body>
</html>
