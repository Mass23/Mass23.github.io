<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Three.js Sphere Viewer with Glitches</title>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; }
    </style>
</head>
<body>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Set up scene, camera, and renderer
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setClearColor(0x000000, 1); // Set the background to black
        document.body.appendChild(renderer.domElement);
        
        // Sphere geometry
        const sphereGeometry = new THREE.SphereGeometry(100, 32, 32);
        const sphereMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff, side: THREE.BackSide });
        const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
        scene.add(sphere);

        // Set camera position
        camera.position.set(0, 0, 0);

        // Load the texture for glitches
        const textureLoader = new THREE.TextureLoader();
        const meImage = textureLoader.load('images/me.webp', (texture) => {
            console.log('Texture loaded:', texture); // Log when texture is loaded

            // Create glitches on the image before using it
            applyGlitchEffect(texture.image, (glitchedTexture) => {
                sphereMaterial.map = glitchedTexture; // Apply the glitched texture to the sphere
                sphereMaterial.needsUpdate = true; // Mark the material as needing an update
                startGlitching(texture.image); // Start periodic glitching
            });
        }, undefined, (error) => {
            console.error('Error loading texture:', error); // Log errors
        });

        // Function to create a coarse gray noise texture
        function createGrayNoiseTexture(width, height) {
            const noiseCanvas = document.createElement('canvas');
            const noiseContext = noiseCanvas.getContext('2d');
            noiseCanvas.width = width;
            noiseCanvas.height = height;

            const imageData = noiseContext.createImageData(width, height);
            for (let i = 0; i < imageData.data.length; i += 4) {
                const gray = Math.random() * 255; // Random gray value
                imageData.data[i] = gray;     // R
                imageData.data[i + 1] = gray; // G
                imageData.data[i + 2] = gray; // B
                imageData.data[i + 3] = 255;  // A
            }
            noiseContext.putImageData(imageData, 0, 0);
            return new THREE.Texture(noiseCanvas);
        }

        // Create the gray noise texture and set it as background
        const noiseTexture = createGrayNoiseTexture(512, 512);
        noiseTexture.needsUpdate = true;

        // Set the background of the scene to gray noise
        scene.background = noiseTexture;

        // Create a canvas for glitches
        const glitchCanvas = document.createElement('canvas');
        const glitchContext = glitchCanvas.getContext('2d');
        glitchCanvas.width = 512; // Set canvas size
        glitchCanvas.height = 512;

        // Function to apply glitch effect directly to the loaded image
        function applyGlitchEffect(image, callback) {
            glitchContext.clearRect(0, 0, glitchCanvas.width, glitchCanvas.height);
            glitchContext.drawImage(image, 0, 0, glitchCanvas.width, glitchCanvas.height);
            
            // Create random glitches with larger patches
            const glitchCount = 15; // Number of glitches
            for (let i = 0; i < glitchCount; i++) {
                const width = Math.floor(Math.random() * 200) + 100; // Width of glitch segment (100-300)
                const height = Math.floor(Math.random() * 200) + 100; // Height of glitch segment (100-300)

                // Randomize x and y coordinates to allow for edge effects
                const x = Math.floor(Math.random() * (glitchCanvas.width + 100)) - 50; // Allow for edge glitches
                const y = Math.floor(Math.random() * (glitchCanvas.height + 100)) - 50; // Allow for edge glitches

                // Ensure we do not go out of bounds while getting the imageData
                const adjustedWidth = Math.min(width, glitchCanvas.width - Math.max(0, x));
                const adjustedHeight = Math.min(height, glitchCanvas.height - Math.max(0, y));

                // Check bounds to avoid accessing out of range
                if (adjustedWidth <= 0 || adjustedHeight <= 0) {
                    continue; // Skip this iteration if the dimensions are invalid
                }

                try {
                    // Get image data
                    const imageData = glitchContext.getImageData(Math.max(0, x), Math.max(0, y), adjustedWidth, adjustedHeight);
                    const glitchX = Math.floor(Math.random() * glitchCanvas.width);
                    const glitchY = Math.floor(Math.random() * glitchCanvas.height);

                    // Put the distorted segment back onto the canvas
                    glitchContext.putImageData(imageData, glitchX, glitchY);
                } catch (error) {
                    console.error('Error getting image data:', error);
                }
            }

            // Create a texture from the glitched canvas
            const glitchedTexture = new THREE.Texture(glitchCanvas);
            glitchedTexture.needsUpdate = true; // Update the texture
            callback(glitchedTexture); // Call the callback with the glitched texture
        }

        // Function to start periodic glitching of the texture
        function startGlitching(originalImage) {
            setInterval(() => {
                applyGlitchEffect(originalImage, (glitchedTexture) => {
                    sphereMaterial.map = glitchedTexture; // Update the material map
                    sphereMaterial.needsUpdate = true; // Mark the material as needing an update
                    console.log('Updated glitched texture'); // Log texture updates
                });
            }, 2000); // Glitch every 2 seconds
        }

        // Variables for sprites
        const sprites = [];
        const MAX_SPRITES = 30; // Limit the number of sprites
        const spriteInterval = 2000; // Generate sprites every 2 seconds

        // Function to create "HELLO WORLD" sprite
        function createHelloWorldSprite() {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = 512; // Increased size
            canvas.height = 512;

            // Draw a noisy square with "HELLO WORLD"
            context.fillStyle = 'rgba(200, 200, 200, 0.5)';
            context.fillRect(0, 0, canvas.width, canvas.height);
            context.fillStyle = 'black';
            context.font = '48px Arial'; // Increased font size
            context.textAlign = 'center';
            context.textBaseline = 'middle';
            context.fillText('HELLO WORLD', canvas.width / 2, canvas.height / 2);

            const spriteTexture = new THREE.Texture(canvas);
            spriteTexture.needsUpdate = true;
            const spriteMaterial = new THREE.SpriteMaterial({ map: spriteTexture });
            const sprite = new THREE.Sprite(spriteMaterial);
            sprite.position.set((Math.random() - 0.5) * 150, (Math.random() - 0.5) * 150, -90); // Random position within the sphere
            scene.add(sprite);
            sprites.push(sprite);

            // Remove oldest sprite if limit exceeded
            if (sprites.length > MAX_SPRITES) {
                const oldestSprite = sprites.shift();
                scene.remove(oldestSprite);
            }
        }

        // Function to create larger pixel sprites
        function createPixelSprite() {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = 256;  // Increased size
            canvas.height = 256;

            // Draw a random pixel sample from the image
            const x = Math.floor(Math.random() * (meImage.image.width - 256));
            const y = Math.floor(Math.random() * (meImage.image.height - 256));
            context.drawImage(meImage.image, x, y, 256, 256, 0, 0, 256, 256);

            const spriteTexture = new THREE.Texture(canvas);
            spriteTexture.needsUpdate = true;
            const spriteMaterial = new THREE.SpriteMaterial({ map: spriteTexture });
            const sprite = new THREE.Sprite(spriteMaterial);
            sprite.position.set((Math.random() - 0.5) * 150, (Math.random() - 0.5) * 150, -90); // Random position within the sphere
            scene.add(sprite);
            sprites.push(sprite);

            // Remove oldest sprite if limit exceeded
            if (sprites.length > MAX_SPRITES) {
                const oldestSprite = sprites.shift();
                scene.remove(oldestSprite);
            }
        }

        // Function to create me.webp sprites
        function createMeSprite() {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = 256; // Increased size
            canvas.height = 256;

            // Draw a random part of the image
            const x = Math.floor(Math.random() * (meImage.image.width - 256));
            const y = Math.floor(Math.random() * (meImage.image.height - 256));
            context.drawImage(meImage.image, x, y, 256, 256, 0, 0, 256, 256);

            const spriteTexture = new THREE.Texture(canvas);
            spriteTexture.needsUpdate = true;
            const spriteMaterial = new THREE.SpriteMaterial({ map: spriteTexture });
            const sprite = new THREE.Sprite(spriteMaterial);
            sprite.position.set((Math.random() - 0.5) * 150, (Math.random() - 0.5) * 150, -90); // Random position within the sphere
            scene.add(sprite);
            sprites.push(sprite);

            // Remove oldest sprite if limit exceeded
            if (sprites.length > MAX_SPRITES) {
                const oldestSprite = sprites.shift();
                scene.remove(oldestSprite);
            }
        }

        // Mouse movement tracking
        let isMouseDown = false;
        let previousMouseX = 0;
        let previousMouseY = 0;

        // Mouse down event to start rotation
        document.addEventListener('mousedown', (event) => {
            isMouseDown = true;
            previousMouseX = event.clientX;
            previousMouseY = event.clientY;
        });

        // Mouse move event to rotate camera
        document.addEventListener('mousemove', (event) => {
            if (!isMouseDown) return;
            const deltaX = event.clientX - previousMouseX;
            const deltaY = event.clientY - previousMouseY;

            // Update camera rotation based on mouse movement
            camera.rotation.y -= deltaX * 0.005; // Adjust sensitivity
            camera.rotation.x -= deltaY * 0.005; // Adjust sensitivity

            previousMouseX = event.clientX;
            previousMouseY = event.clientY;
        });

        // Mouse up event to stop rotation
        document.addEventListener('mouseup', () => {
            isMouseDown = false;
        });

        // Resize event
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }

        // Create initial sprites
        setInterval(() => {
            createHelloWorldSprite();
            createPixelSprite();
            createMeSprite();
        }, 2000); // Create sprites every 2 seconds

        // Start animation loop
        animate();
    </script>
</body>
</html>
