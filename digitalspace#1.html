<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Three.js Sphere Viewer</title>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; }
    </style>
</head>
<body>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Set up scene, camera, and renderer
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);
        
        // Sphere geometry
        const sphereGeometry = new THREE.SphereGeometry(100, 32, 32);
        const sphereMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff, side: THREE.BackSide });
        const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
        scene.add(sphere);

        // Set camera position
        camera.position.set(0, 0, 0);

        // Load the texture
        const textureLoader = new THREE.TextureLoader();
        let sphereTexture = textureLoader.load('images/me.webp');
        
        // Function to update the texture with a glitch effect
        function updateSphereTexture() {
            sphereTexture = textureLoader.load('images/me.webp', function(texture) {
                texture.wrapS = THREE.RepeatWrapping;
                texture.wrapT = THREE.RepeatWrapping;
                texture.repeat.set(1, 1);
                sphereMaterial.map = texture;
                sphereMaterial.needsUpdate = true;
            });
        }

        setInterval(updateSphereTexture, 1000); // Update every second

        // Function to create "HELLO WORLD" sprite
        function createHelloWorldSprite() {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = 128;
            canvas.height = 128;

            // Draw a noisy square with "HELLO WORLD"
            context.fillStyle = 'rgba(200, 200, 200, 0.5)';
            context.fillRect(0, 0, canvas.width, canvas.height);
            context.fillStyle = 'black';
            context.font = '20px Arial';
            context.textAlign = 'center';
            context.textBaseline = 'middle';
            context.fillText('HELLO WORLD', canvas.width / 2, canvas.height / 2);

            const spriteTexture = new THREE.Texture(canvas);
            spriteTexture.needsUpdate = true;
            const spriteMaterial = new THREE.SpriteMaterial({ map: spriteTexture });
            const sprite = new THREE.Sprite(spriteMaterial);
            sprite.position.set((Math.random() - 0.5) * 50, (Math.random() - 0.5) * 50, -95);
            scene.add(sprite);
        }

        // Function to create small pixel sprites
        function createPixelSprite() {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = 32;
            canvas.height = 32;

            // Draw a random pixel sample from the image
            const x = Math.floor(Math.random() * 100);
            const y = Math.floor(Math.random() * 100);
            context.drawImage(document.querySelector('img#meImage'), x, y, 32, 32, 0, 0, 32, 32);

            const spriteTexture = new THREE.Texture(canvas);
            spriteTexture.needsUpdate = true;
            const spriteMaterial = new THREE.SpriteMaterial({ map: spriteTexture });
            const sprite = new THREE.Sprite(spriteMaterial);
            sprite.position.set((Math.random() - 0.5) * 50, (Math.random() - 0.5) * 50, -95);
            scene.add(sprite);
        }

        // Create the me.webp image for sampling pixels
        const meImage = new Image();
        meImage.src = 'images/me.webp';
        meImage.id = 'meImage';
        meImage.onload = function() {
            setInterval(() => {
                createHelloWorldSprite();
                createPixelSprite();
            }, 1000); // Generate sprites every second
        };

        // Mouse control for movement
        document.addEventListener('click', (event) => {
            const mouseX = (event.clientX / window.innerWidth) * 2 - 1;
            const mouseY = -(event.clientY / window.innerHeight) * 2 + 1;
            const direction = new THREE.Vector3(mouseX, mouseY, 0.5).unproject(camera).sub(camera.position).normalize();
            camera.position.add(direction.multiplyScalar(-1)); // Move opposite to mouse direction
        });

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }

        animate();
    </script>
</body>
</html>
