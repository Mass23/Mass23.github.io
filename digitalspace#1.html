<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Three.js Sphere Viewer</title>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; }
    </style>
</head>
<body>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Set up scene, camera, and renderer
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Sphere geometry
        const sphereGeometry = new THREE.SphereGeometry(100, 32, 32);
        const sphereMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff, side: THREE.BackSide });
        const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
        scene.add(sphere);

        // Set camera position
        camera.position.set(0, 0, 0);

        // Load the texture for sprites
        const textureLoader = new THREE.TextureLoader();
        const meImage = textureLoader.load('images/me.webp', (texture) => {
            createGrayNoiseBackground(); // Create and apply gray noise background
            startSpriteCreation(); // Start creating sprites
        }, undefined, (error) => {
            console.error('Error loading texture:', error); // Log errors
        });

        // Create a canvas for gray noise
        const noiseCanvas = document.createElement('canvas');
        const noiseContext = noiseCanvas.getContext('2d');
        noiseCanvas.width = 512;
        noiseCanvas.height = 512;

        // Function to create a coarse gray noise texture
        function createGrayNoiseBackground() {
            const imageData = noiseContext.createImageData(noiseCanvas.width, noiseCanvas.height);
            for (let i = 0; i < imageData.data.length; i += 4) {
                const gray = Math.random() * 255; // Random gray value
                imageData.data[i] = gray;     // R
                imageData.data[i + 1] = gray; // G
                imageData.data[i + 2] = gray; // B
                imageData.data[i + 3] = 255;  // A
            }
            noiseContext.putImageData(imageData, 0, 0);
            const noiseTexture = new THREE.Texture(noiseCanvas);
            noiseTexture.needsUpdate = true;
            scene.background = noiseTexture; // Set the noise texture as the scene background

            // Create noise texture for animation
            animateNoise();
        }

        // Function to animate the noise background
        function animateNoise() {
            setInterval(() => {
                const imageData = noiseContext.getImageData(0, 0, noiseCanvas.width, noiseCanvas.height);
                for (let i = 0; i < imageData.data.length; i += 4) {
                    const gray = Math.random() * 255; // Random gray value
                    imageData.data[i] = gray;     // R
                    imageData.data[i + 1] = gray; // G
                    imageData.data[i + 2] = gray; // B
                }
                noiseContext.putImageData(imageData, 0, 0);
                noiseCanvas.needsUpdate = true;
            }, 1000); // Update noise every second
        }

        // Variables for sprites
        const sprites = [];
        const MAX_SPRITES = 30; // Limit the number of sprites
        const spriteInterval = 2000; // Generate sprites every 2 seconds

        // Function to create "HELLO WORLD" sprite
        function createHelloWorldSprite() {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = 512; // Increased size
            canvas.height = 512;

            // Draw a noisy square with "HELLO WORLD"
            context.fillStyle = 'rgba(200, 200, 200, 0.5)';
            context.fillRect(0, 0, canvas.width, canvas.height);
            context.fillStyle = 'black';
            context.font = '48px Arial'; // Increased font size
            context.textAlign = 'center';
            context.textBaseline = 'middle';
            context.fillText('HELLO WORLD', canvas.width / 2, canvas.height / 2);

            const spriteTexture = new THREE.Texture(canvas);
            spriteTexture.needsUpdate = true;
            const spriteMaterial = new THREE.SpriteMaterial({ map: spriteTexture });
            const sprite = new THREE.Sprite(spriteMaterial);
            sprite.position.set((Math.random() - 0.5) * 150, (Math.random() - 0.5) * 150, -90); // Random position within the sphere
            scene.add(sprite);
            sprites.push(sprite);

            // Remove oldest sprite if limit exceeded
            if (sprites.length > MAX_SPRITES) {
                const oldestSprite = sprites.shift();
                scene.remove(oldestSprite);
            }
        }

        // Function to create larger pixel sprites
        function createPixelSprite() {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = 256;  // Increased size
            canvas.height = 256;

            // Draw a random pixel sample from the image
            const x = Math.floor(Math.random() * (meImage.image.width - 256));
            const y = Math.floor(Math.random() * (meImage.image.height - 256));
            context.drawImage(meImage.image, x, y, 256, 256, 0, 0, 256, 256);

            const spriteTexture = new THREE.Texture(canvas);
            spriteTexture.needsUpdate = true;
            const spriteMaterial = new THREE.SpriteMaterial({ map: spriteTexture });
            const sprite = new THREE.Sprite(spriteMaterial);
            sprite.position.set((Math.random() - 0.5) * 150, (Math.random() - 0.5) * 150, -90); // Random position within the sphere
            scene.add(sprite);
            sprites.push(sprite);

            // Remove oldest sprite if limit exceeded
            if (sprites.length > MAX_SPRITES) {
                const oldestSprite = sprites.shift();
                scene.remove(oldestSprite);
            }
        }

        // Function to create me.webp sprites
        function createMeSprite() {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = 256; // Increased size
            canvas.height = 256;

            // Draw a random part of the image
            const x = Math.floor(Math.random() * (meImage.image.width - 256));
            const y = Math.floor(Math.random() * (meImage.image.height - 256));
            context.drawImage(meImage.image, x, y, 256, 256, 0, 0, 256, 256);

            const spriteTexture = new THREE.Texture(canvas);
            spriteTexture.needsUpdate = true;
            const spriteMaterial = new THREE.SpriteMaterial({ map: spriteTexture });
            const sprite = new THREE.Sprite(spriteMaterial);
            sprite.position.set((Math.random() - 0.5) * 150, (Math.random() - 0.5) * 150, -90); // Random position within the sphere
            scene.add(sprite);
            sprites.push(sprite);

            // Remove oldest sprite if limit exceeded
            if (sprites.length > MAX_SPRITES) {
                const oldestSprite = sprites.shift();
                scene.remove(oldestSprite);
            }
        }

        // Function to start creating sprites
        function startSpriteCreation() {
            setInterval(() => {
                createHelloWorldSprite();
                createPixelSprite();
                createMeSprite();
            }, spriteInterval); // Create sprites every 2 seconds
        }

        // Mouse control for sprite and camera movement
        let isMouseDown = false;
        let mouseX = 0;
        let mouseY = 0;

        window.addEventListener('mousedown', (event) => {
            isMouseDown = true;
            mouseX = event.clientX;
            mouseY = event.clientY;
        });

        window.addEventListener('mouseup', () => {
            isMouseDown = false;
        });

        window.addEventListener('mousemove', (event) => {
            if (isMouseDown) {
                const deltaX = event.clientX - mouseX;
                const deltaY = event.clientY - mouseY;

                // Rotate camera based on mouse movement
                camera.rotation.y -= deltaX * 0.005;
                camera.rotation.x -= deltaY * 0.005;

                mouseX = event.clientX;
                mouseY = event.clientY;
            }
        });

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }

        animate();
    </script>
</body>
</html>
