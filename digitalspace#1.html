<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Digital Space #1 - Hello World</title>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; }
    </style>
</head>
<body>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Set up scene, camera, and renderer
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Sphere geometry
        const sphereGeometry = new THREE.SphereGeometry(100, 32, 32);
        
        // Load the texture for the sphere
        const textureLoader = new THREE.TextureLoader();
        textureLoader.load('images/me.webp', (image) => {
            // Shuffle the image pixels and set it as the texture for the sphere
            shuffleImage(image, (shuffledTexture) => {
                const sphereMaterial = new THREE.MeshBasicMaterial({ map: shuffledTexture, side: THREE.BackSide });
                const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
                scene.add(sphere);
                
                startSpriteCreation(); // Start creating sprites after loading the texture
            });
        }, undefined, (error) => {
            console.error('Error loading texture:', error); // Log errors
        });

        // Set camera position to be inside the sphere
        camera.position.set(0, 0, 0);

        // Function to shuffle image pixels
        function shuffleImage(image, callback) {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = image.image.width;  
            canvas.height = image.image.height; 

            context.drawImage(image.image, 0, 0); 

            const imageData = context.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;

            // Shuffle the pixels
            for (let i = data.length / 4 - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                // Swap pixels
                const tmpR = data[i * 4];
                const tmpG = data[i * 4 + 1];
                const tmpB = data[i * 4 + 2];
                const tmpA = data[i * 4 + 3];
                data[i * 4] = data[j * 4];
                data[i * 4 + 1] = data[j * 4 + 1];
                data[i * 4 + 2] = data[j * 4 + 2];
                data[i * 4 + 3] = data[j * 4 + 3];
                data[j * 4] = tmpR;
                data[j * 4 + 1] = tmpG;
                data[j * 4 + 2] = tmpB;
                data[j * 4 + 3] = tmpA;
            }

            context.putImageData(imageData, 0, 0);
            const shuffledTexture = new THREE.Texture(canvas);
            shuffledTexture.needsUpdate = true;

            callback(shuffledTexture); // Pass the shuffled texture back
        }

        // Variables for sprites
        const sprites = [];
        const MAX_SPRITES = 1000; // Limit the number of sprites
        const spriteInterval = 100; // Generate sprites every 100 milliseconds
        const SPHERE_RADIUS = 100; // Sphere radius
        const meImage = new Image(); // Image for MeSprites
        meImage.src = 'images/me.webp'; // Path to me.webp

        meImage.onload = () => {
            // Start sprite creation after the image is loaded
            startSpriteCreation();
        };

        // Function to create "HELLO WORLD" sprite
        function createHelloWorldSprite() {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = 512 * 10; // Increased size
            canvas.height = 512 * 10;

            // Draw a noisy square with "HELLO WORLD"
            context.fillStyle = 'rgba(200, 200, 200, 0.5)';
            context.fillRect(0, 0, canvas.width, canvas.height);
            context.fillStyle = 'black';
            context.font = '48px Arial'; // Increased font size
            context.textAlign = 'center';
            context.textBaseline = 'middle';
            context.fillText('HELLO WORLD', canvas.width / 2, canvas.height / 2);

            const spriteTexture = new THREE.Texture(canvas);
            spriteTexture.needsUpdate = true;
            const spriteMaterial = new THREE.SpriteMaterial({ map: spriteTexture });
            const sprite = new THREE.Sprite(spriteMaterial);

            // Position the sprite close to the sphere's inner surface
            positionSprite(sprite, SPHERE_RADIUS - 30); // Adjust position
            // Scale up the MeSprite size
            sprite.scale.set(4, 4, 1); // Set MeSprite size (x, y, z)

            scene.add(sprite);
            sprites.push(sprite);

            // Remove oldest sprite if limit exceeded
            if (sprites.length > MAX_SPRITES) {
                const oldestSprite = sprites.shift();
                scene.remove(oldestSprite);
            }
        }

        // Function to create larger pixel sprites
        function createPixelSprite() {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = 512;  // Increased size
            canvas.height = 512;

            // Draw a random pixel sample from the image
            const x = Math.floor(Math.random() * (meImage.width - 256));
            const y = Math.floor(Math.random() * (meImage.height - 256));
            context.drawImage(meImage, x, y, 256, 256, 0, 0, 256, 256);

            const spriteTexture = new THREE.Texture(canvas);
            spriteTexture.needsUpdate = true;
            const spriteMaterial = new THREE.SpriteMaterial({ map: spriteTexture });
            const sprite = new THREE.Sprite(spriteMaterial);

            // Position the sprite closer to the center of the sphere
            positionSprite(sprite, SPHERE_RADIUS - 50); // Adjust position
            sprite.userData.type = 'pixel'; // Set userData for pixel sprite
            // Scale up the MeSprite size
            sprite.scale.set(4, 4, 1); // Set MeSprite size (x, y, z)

            scene.add(sprite);
            sprites.push(sprite);

            // Remove oldest sprite if limit exceeded
            if (sprites.length > MAX_SPRITES) {
                const oldestSprite = sprites.shift();
                scene.remove(oldestSprite);
            }
        }

        // Function to create MeSprites
        function createMeSprite() {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = 512 * 7;  // Size of MeSprites
            canvas.height = 512 * 7;

            // Draw a random part of the me image
            const x = Math.floor(Math.random() * (meImage.width - 256));
            const y = Math.floor(Math.random() * (meImage.height - 256));
            context.drawImage(meImage, x, y, 256, 256, 0, 0, 256, 256);

            const spriteTexture = new THREE.Texture(canvas);
            spriteTexture.needsUpdate = true;
            const spriteMaterial = new THREE.SpriteMaterial({ map: spriteTexture });
            const sprite = new THREE.Sprite(spriteMaterial);

            // Position the sprite close to the sphere's inner surface
            positionSprite(sprite, SPHERE_RADIUS - 40); // Adjust position
            sprite.userData.type = 'me'; // Set userData for MeSprite
            // Scale up the MeSprite size
            sprite.scale.set(4, 4, 1); // Set MeSprite size (x, y, z)

            scene.add(sprite);
            sprites.push(sprite);

            // Remove oldest sprite if limit exceeded
            if (sprites.length > MAX_SPRITES) {
                const oldestSprite = sprites.shift();
                scene.remove(oldestSprite);
            }
        }

        // Function to position sprites
        function positionSprite(sprite, distanceFromCenter) {
            // Random position around the sphere's inner surface
            const phi = Math.random() * Math.PI; // Random angle
            const theta = Math.random() * 2 * Math.PI; // Random angle

            sprite.position.set(
                distanceFromCenter * Math.sin(phi) * Math.cos(theta),
                distanceFromCenter * Math.sin(phi) * Math.sin(theta),
                distanceFromCenter * Math.cos(phi)
            );
        }

        // Function to start creating sprites
        function startSpriteCreation() {
            setInterval(() => {
                for (let i = 0; i < 1; i++) {
                    createHelloWorldSprite();
                    }
                for (let i = 0; i < 10; i++) {
                    createPixelSprite();
                    }
                for (let i = 0; i < 3; i++) {
                    createMeSprite();
                    }
            }, spriteInterval);
        }

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);

            // Update the position of pixel sprites to follow the camera
            sprites.forEach(sprite => {
                if (sprite.userData.type === 'pixel') { // Only update pixel sprites
                    const distanceFromCenter = SPHERE_RADIUS - 20; // Maintain distance
                    sprite.position.normalize(); // Normalize the sprite's position vector
                    sprite.position.multiplyScalar(distanceFromCenter); // Scale to the sphere's radius
                }
            });

            renderer.render(scene, camera);
        }
        animate(); // Start the animation loop

        // Handle mouse movement
        let isMouseDown = false;
        let lastMouseX = 0;
        let lastMouseY = 0;

        window.addEventListener('mousedown', (event) => {
            isMouseDown = true;
            lastMouseX = event.clientX;
            lastMouseY = event.clientY;
        });

        window.addEventListener('mouseup', () => {
            isMouseDown = false;
        });

        window.addEventListener('mousemove', (event) => {
            if (isMouseDown) {
                const deltaX = event.clientX - lastMouseX;
                const deltaY = event.clientY - lastMouseY;

                // Update camera rotation based on mouse movement
                camera.rotation.y -= deltaX * 0.005; // Adjust sensitivity as needed
                camera.rotation.x -= deltaY * 0.005;

                // Clamp the camera's x rotation to prevent flipping
                camera.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, camera.rotation.x));

                lastMouseX = event.clientX;
                lastMouseY = event.clientY;
            }
        });

        // Handle touch events for mobile support
        window.addEventListener('touchstart', (event) => {
            isMouseDown = true;
            lastMouseX = event.touches[0].clientX;
            lastMouseY = event.touches[0].clientY;
        });

        window.addEventListener('touchend', () => {
            isMouseDown = false;
        });

        window.addEventListener('touchmove', (event) => {
            if (isMouseDown) {
                const deltaX = event.touches[0].clientX - lastMouseX;
                const deltaY = event.touches[0].clientY - lastMouseY;

                // Update camera rotation based on touch movement
                camera.rotation.y -= deltaX * 0.005; // Adjust sensitivity as needed
                camera.rotation.x -= deltaY * 0.005;

                // Clamp the camera's x rotation to prevent flipping
                camera.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, camera.rotation.x));

                lastMouseX = event.touches[0].clientX;
                lastMouseY = event.touches[0].clientY;
            }
        });

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
