<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Three.js Fixed Pixel Sprites</title>
    <style>
        body { margin: 0; }
        canvas { display: block; }
    </style>
</head>
<body>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Scene setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Texture loader
        const textureLoader = new THREE.TextureLoader();
        const imageTexture = textureLoader.load('images/me.webp', (texture) => {
            // Crop 50 pixels from each side
            const cropAmount = 50;
            const width = texture.image.width;
            const height = texture.image.height;

            texture.offset.set(cropAmount / width, cropAmount / height); // Set the offset to start cropping from (50px from each side)
            texture.repeat.set((width - 2 * cropAmount) / width, (height - 2 * cropAmount) / height); // Repeat to fill the sphere with the cropped image
            texture.needsUpdate = true; // Update the texture
        });

        // Create a sphere geometry (textured inside)
        const geometry = new THREE.SphereGeometry(20, 32, 32);
        const material = new THREE.MeshBasicMaterial({
            map: imageTexture,
            side: THREE.BackSide  // Texture is applied inside the sphere
        });
        const sphere = new THREE.Mesh(geometry, material);
        scene.add(sphere);

        // Create a basic texture for the text background
        const createTextBackground = () => {
            const canvas = document.createElement('canvas');
            canvas.width = 200;  // Increased size for the square
            canvas.height = 200; // Increased size for the square
            const context = canvas.getContext('2d');
            context.fillStyle = '#cccccc'; // Light grey background
            context.fillRect(0, 0, canvas.width, canvas.height);
            context.fillStyle = 'rgba(255, 255, 255, 0.8)'; // White text
            context.font = 'bold 30px Arial'; // Adjusted font size
            context.textAlign = 'center';
            context.fillText('HELLO WORLD', canvas.width / 2, canvas.height / 2 + 10); // Adjusted position
            return new THREE.CanvasTexture(canvas);
        };

        // Function to create sprites with randomly sampled pixels from the image
        function createRandomSprites() {
            const spriteMaterial = new THREE.SpriteMaterial({ map: null, transparent: true, opacity: 1 });

            // Randomly sample a small portion from the texture
            const sampleX = Math.random() * (imageTexture.image.width - 1);
            const sampleY = Math.random() * (imageTexture.image.height - 1);

            const croppedTexture = new THREE.Texture(imageTexture.image);
            croppedTexture.offset.set(sampleX / imageTexture.image.width, sampleY / imageTexture.image.height);
            croppedTexture.repeat.set(0.1, 0.1); // Sample larger portion for visibility
            croppedTexture.needsUpdate = true;

            spriteMaterial.map = croppedTexture;

            const sprite = new THREE.Sprite(spriteMaterial);

            // Set a fixed position for the sprite within the sphere
            const radius = 15; // Random distance from the center
            const theta = Math.random() * 2 * Math.PI;
            const phi = Math.acos(2 * Math.random() - 1);
            sprite.position.set(
                radius * Math.sin(phi) * Math.cos(theta),
                radius * Math.sin(phi) * Math.sin(theta),
                radius * Math.cos(phi)
            );

            // Set size of the sprite (smaller than before)
            sprite.scale.set(0.5, 0.5, 0.5); // Smaller size
            scene.add(sprite);

            // Slowly fade away
            const fadeTime = 3; // Seconds to fade
            let fadeOut = setInterval(() => {
                spriteMaterial.opacity -= 0.05;
                if (spriteMaterial.opacity <= 0) {
                    clearInterval(fadeOut);
                    scene.remove(sprite); // Remove the sprite when fully transparent
                }
            }, fadeTime * 1000 / 20); // Fade out over time
        }

        // Create text sprite at a fixed position inside the sphere
        function createTextSprite() {
            const textMaterial = new THREE.SpriteMaterial({ map: createTextBackground(), transparent: true });
            const textSprite = new THREE.Sprite(textMaterial);

            // Set a fixed position for the text sprite within the sphere
            const radius = 12; // Distance from the center
            const theta = Math.random() * 2 * Math.PI;
            const phi = Math.acos(2 * Math.random() - 1);
            textSprite.position.set(
                radius * Math.sin(phi) * Math.cos(theta),
                radius * Math.sin(phi) * Math.sin(theta),
                radius * Math.cos(phi)
            );

            // Set size of the text sprite (same as image size)
            textSprite.scale.set(1, 1, 1); // Adjust this for size
            scene.add(textSprite);

            // Slowly fade out text sprite
            const fadeTime = 3; // Seconds to fade
            let fadeOut = setInterval(() => {
                textMaterial.opacity -= 0.05;
                if (textMaterial.opacity <= 0) {
                    clearInterval(fadeOut);
                    scene.remove(textSprite); // Remove the sprite when fully transparent
                }
            }, fadeTime * 1000 / 20); // Fade out over time
        }

        // Create sprites and text every 50 milliseconds for overwhelming presence
        setInterval(() => {
            createRandomSprites();
            createTextSprite();
            createImageSprite(); // Generate me.webp image more often
        }, 50);

        // Function to create me.webp sprites
        function createImageSprite() {
            const spriteMaterial = new THREE.SpriteMaterial({ map: imageTexture, transparent: true });
            const imageSprite = new THREE.Sprite(spriteMaterial);

            // Set a fixed position for the image sprite within the sphere
            const radius = 10; // Distance from the center
            const theta = Math.random() * 2 * Math.PI;
            const phi = Math.acos(2 * Math.random() - 1);
            imageSprite.position.set(
                radius * Math.sin(phi) * Math.cos(theta),
                radius * Math.sin(phi) * Math.sin(theta),
                radius * Math.cos(phi)
            );

            // Set size of the image sprite (same as text size)
            imageSprite.scale.set(1, 1, 1); // Adjust this for size
            scene.add(imageSprite);

            // Slowly fade out image sprite
            const fadeTime = 3; // Seconds to fade
            let fadeOut = setInterval(() => {
                spriteMaterial.opacity -= 0.05;
                if (spriteMaterial.opacity <= 0) {
                    clearInterval(fadeOut);
                    scene.remove(imageSprite); // Remove the sprite when fully transparent
                }
            }, fadeTime * 1000 / 20); // Fade out over time
        }

        // Set camera position inside the sphere
        camera.position.set(0, 0, 0);

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }

        animate();

        // Rotate camera in the opposite direction when clicking
        let isMouseDown = false;
        document.addEventListener('mousedown', () => { isMouseDown = true; });
        document.addEventListener('mouseup', () => { isMouseDown = false; });

        document.addEventListener('mousemove', (event) => {
            if (isMouseDown) {
                const movementX = event.movementX || event.mozMovementX || event.webkitMovementX || 0;
                const movementY = event.movementY || event.mozMovementY || event.webkitMovementY || 0;

                // Move camera in the opposite direction
                camera.rotation.y -= movementX * 0.002; // Reverse direction
                camera.rotation.x -= movementY * 0.002; // Reverse direction
            }
        });

    </script>
</body>
</html>
