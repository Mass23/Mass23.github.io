<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Three.js Sphere with Noisy Background and Fixed Objects</title>
    <style>
        body { margin: 0; }
        canvas { display: block; }
    </style>
</head>
<body>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Scene setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Texture loader
        const textureLoader = new THREE.TextureLoader();
        const imageTexture = textureLoader.load('images/me.webp');

        // Create a sphere geometry
        const geometry = new THREE.SphereGeometry(20, 32, 32);

        // Apply texture to the inside of the sphere
        imageTexture.wrapS = THREE.RepeatWrapping;
        imageTexture.wrapT = THREE.RepeatWrapping;
        imageTexture.repeat.set(-1, 1);  // Flip texture horizontally

        const material = new THREE.MeshBasicMaterial({
            map: imageTexture,
            side: THREE.BackSide,  // Texture applied to the inside of the sphere
        });

        const sphere = new THREE.Mesh(geometry, material);
        scene.add(sphere);

        camera.position.z = 50;  // Set camera inside the sphere

        // Generate noisy background for "Hello World" text
        function generateNoisyTexture(width, height) {
            const canvas = document.createElement('canvas');
            canvas.width = width;
            canvas.height = height;
            const context = canvas.getContext('2d');
            const imageData = context.createImageData(width, height);
            for (let i = 0; i < imageData.data.length; i += 4) {
                const value = Math.random() * 255; // Generate random grey value
                imageData.data[i] = value;
                imageData.data[i + 1] = value;
                imageData.data[i + 2] = value;
                imageData.data[i + 3] = 255; // Full opacity
            }
            context.putImageData(imageData, 0, 0);
            const texture = new THREE.CanvasTexture(canvas);
            return texture;
        }

        // Create a sprite with "Hello World" text on a noisy background
        function createTextSprite(text) {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            const width = 512;  // Same size as the texture (e.g. me.webp)
            const height = 512;
            canvas.width = width;
            canvas.height = height;

            // Draw noisy background
            const noisyTexture = generateNoisyTexture(width, height);
            context.drawImage(noisyTexture.image, 0, 0);

            // Draw text
            context.font = 'Bold 40px Arial';
            context.fillStyle = 'white';
            context.textAlign = 'center';
            context.textBaseline = 'middle';
            context.fillText(text, width / 2, height / 2);

            const texture = new THREE.CanvasTexture(canvas);
            const spriteMaterial = new THREE.SpriteMaterial({ map: texture });
            const sprite = new THREE.Sprite(spriteMaterial);

            sprite.scale.set(10, 10, 1);  // Set size of sprite
            return sprite;
        }

        // Place the text sprite randomly inside the sphere
        function placeSpriteInsideSphere(sprite) {
            const phi = Math.random() * Math.PI * 2;
            const theta = Math.random() * Math.PI;
            const radius = 18;  // Slightly inside the sphere

            sprite.position.set(
                radius * Math.sin(theta) * Math.cos(phi),
                radius * Math.sin(theta) * Math.sin(phi),
                radius * Math.cos(theta)
            );

            scene.add(sprite);

            // Slowly fade away after 3 seconds
            setTimeout(() => {
                sprite.material.transparent = true;
                const fadeInterval = setInterval(() => {
                    sprite.material.opacity -= 0.01;
                    if (sprite.material.opacity <= 0) {
                        clearInterval(fadeInterval);
                        scene.remove(sprite);  // Remove sprite when fully transparent
                    }
                }, 50);
            }, 3000);
        }

        // Create and place multiple text and image sprites
        function createFloatingObjects() {
            // Create "Hello World" sprite
            const helloWorldSprite = createTextSprite('HELLO WORLD');
            placeSpriteInsideSphere(helloWorldSprite);

            // Create image sprite
            const imageMaterial = new THREE.SpriteMaterial({ map: imageTexture });
            const imageSprite = new THREE.Sprite(imageMaterial);
            imageSprite.scale.set(10, 10, 1);  // Set size of image
            placeSpriteInsideSphere(imageSprite);

            // Repeat every 5 seconds
            setTimeout(createFloatingObjects, 5000);
        }

        // Call the function to start generating objects
        createFloatingObjects();

        // Mouse control variables
        let isMouseDown = false;
        let mouseX = 0, mouseY = 0;
        let prevMouseX = 0, prevMouseY = 0;

        // Mouse down event to start moving the camera
        document.addEventListener('mousedown', function (event) {
            isMouseDown = true;
            prevMouseX = event.clientX;
            prevMouseY = event.clientY;
        });

        // Mouse up event to stop moving the camera
        document.addEventListener('mouseup', function () {
            isMouseDown = false;
        });

        // Mouse move event to rotate the camera in the opposite direction of the mouse movement
        document.addEventListener('mousemove', function (event) {
            if (!isMouseDown) return;

            mouseX = event.clientX;
            mouseY = event.clientY;

            const deltaX = mouseX - prevMouseX;
            const deltaY = mouseY - prevMouseY;

            // Move camera in the opposite direction
            camera.rotation.y -= deltaX * 0.002;  // Yaw (left/right)
            camera.rotation.x -= deltaY * 0.002;  // Pitch (up/down)

            prevMouseX = mouseX;
            prevMouseY = mouseY;
        });

        // Render loop
        function render() {
            renderer.render(scene, camera);
            requestAnimationFrame(render);
        }

        render();

        // Handle window resizing
        window.addEventListener('resize', function () {
            renderer.setSize(window.innerWidth, window.innerHeight);
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
        });
    </script>
</body>
</html>
